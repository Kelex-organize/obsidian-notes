Un algoritmo codicioso construye una solución paso a paso, eligiendo en cada paso la opción localmente optima con la esperanza de llegar a una solución globalmente optima

# Planificación de Intervalos
**Problema:** Dado un conjunto de intervalos [s_i, f_i], seleccionar la mayor cantidad de intervalos no solapados.
### Algoritmo
1. Ordenar los intervalos por tiempo de finalización.
2. Seleccionar el primer intervalo (el que termina antes).
3. Iterativamente, seleccionar el siguiente intervalo que comience después de que termine el último elegido.
### Análisis
- **Correctitud:** se cumple la propiedad de elección codiciosa (elegir el que termina antes deja más espacio para los siguientes).
- **Complejidad:**
	- Ordenamiento: O(n \log n).
	- Selección: O(n).
	- Total: O(n \log n).
# Minimizar Tardanza
**Problema:** Dadas n tareas con tiempo de ejecución y fecha límite, queremos minimizar la cantidad de tareas retrasadas.
### Algoritmo
1. Ordenar las tareas en orden creciente de sus fechas límite.
2. Programarlas en ese orden.
### Análisis
- **Correctitud:** demostrada con el argumento de intercambio \rightarrow si dos tareas están en orden incorrecto, intercambiarlas no empeora la solución.
- **Complejidad:**
	- Ordenamiento: O(n \log n).
	- Programación: O(n).
	- Total: O(n \log n).

# Camino Más Corto en un Grafo
**Problema:** Encontrar el camino más corto desde un nodo origen a todos los demás en un grafo con aristas de peso no negativo.
### Algoritmo 
1. Inicializar distancias: d[s] = 0, el resto infinito
2. Usar una cola de prioridad: en cada paso elegir el nodo con menos distancia temporal.
3. Relajar sus aristas actualizando distancias si se encuentra un camino más corto.
4. Repetir hasta procesar todos los nodos.

### Análisis
- **Correctitud:** elección codiciosa \rightarrow siempre elegir el nodo más cercano no procesado mantiene la optimalidad.
- **Complejidad:**
	- Con montículo binario: O((V + E) \log V).
- **Limitación:** no admite pesos negativos.

# Árbol de Recubrimiento Mínimo
**Problema:** Dado un grafo conexo y ponderado, encontrar un subconjunto de aristas que conecte todos los nodos con peso total mínimo.
### Algoritmo


### Análisis
- **Correctitud:** 
- **Complejidad:**

