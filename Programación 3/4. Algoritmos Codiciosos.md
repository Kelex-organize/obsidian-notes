Un algoritmos codicioso es una estrategia de resolución de problemas en la que se construye una solución paso a paso, tomando en cada paso la mejor decisión posible en ese momento, conocida como elección local óptima, con la esperanza de alcanzar una solución global óptima.
### Correctitud condicionada
Funcionan correctamente si el problema cumple dos propiedades
- **Subestructura óptima:** una solución óptima del problema contiene soluciones óptimas de sus subproblemas.
- **Propiedad de elección codiciosa:** se puede construir una solución óptima haciendo elecciones locales óptimas.

# Planificación de Intervalos
**Problema:** Dado un conjunto de intervalos $[s_i, f_i]$, seleccionar la mayor cantidad de intervalos no solapados.
### Algoritmo Interval-Scheduling
1. Ordenar los intervalos por tiempo de finalización.
2. Seleccionar el primer intervalo (el que termina antes).
3. Iterativamente, seleccionar el siguiente intervalo que comience después de que termine el último elegido.
```
Interval-Scheduling(R)
	Consideramos a R el conjunto de solicitudes y lo ordenamos de forma creciente f(i).
	A = vacío
	while R ≠ ∅ do
	    Elijo el primer elemento de R y lo agrego a A
	    Elimino de R dicho elemento y todos los que se solapan con él
	end while
	return A
```
### Análisis
- **Correctitud:** elegir siempre el intervalo que termina primero deja más espacio para los siguientes intervalos. Además, se cumple la **subestructura óptima**, ya que la solución óptima para todo el conjunto contiene soluciones óptimas para subconjuntos restantes.
- **Complejidad:**
	- Ordenamiento: $O(n \log n)$.
	- Selección: $O(n)$.
	- **Total:** $O(n \log n)$.

# Minimizar Tardanza
**Problema:** Dadas $n$ tareas, cada una con un tiempo de ejecución y una fecha límite, queremos programarlas de manera que se minimice la cantidad de tareas retrasadas (tardanza).
### Algoritmo Earliest-Deadline-First
1. Ordenar las tareas en orden creciente de sus fechas límite.
2. Programarlas en ese orden.
```
Earliest-Deadline-First(T)
	Consideramos a T el conjunto de tareas
	Ordenamos T de forma creciente según su fecha límite
	for cada tarea t en T do
	    Programar t al final de las tareas ya programadas
	end for
```
### Análisis
- **Correctitud:** si dos tareas están en orden incorrecto (la de fecha límite más tardía antes de la más temprana), intercambiarlas no empeora la solución. Repetidos intercambios muestran que el orden por fecha límite minimiza la tardanza
- **Complejidad:**
	- Ordenamiento: $O(n \log n)$.
	- Programación: $O(n)$.
	- **Total:** $O(n \log n)$.

# Camino Más Corto en un Grafo
**Problema:** Dado un grafo ponderado con aristas de peso no negativo y un nodo origen, encontrar la distancia mínima desde el nodo origen a todos los demás nodos del grafo.
### Algoritmo Dijkstra
1. Inicializar todas las distancias: $d[s] = 0$ y el resto infinito.
2. Mantener un conjunto de nodos procesados y una cola de prioridad con los nodos pendientes, priorizando menor distancia temporal.
3. En cada paso:
    - Elegir el nodo con la menor distancia temporal.
    - Relajar todas sus aristas hacia los nodos vecinos (actualizar distancias si se encuentra un camino más corto).
4. Repetir hasta procesar todos los nodos.
```
Dijkstra(S,V)
	Inicializo S = {origen}
	d(origen) = 0, resto infinito
	while S != V do
	    Considero todas las aristas (u,v) con u en S y v en V \ S
	    Selecciono la arista que minimiza d(u) + peso(u,v)
	    Agrego v a S
	    Actualizo d(v) = d(u) + peso(u,v)
	end while
	return d
```
### Análisis
- **Correctitud:** La elección codiciosa de tomar siempre el nodo con menor distancia temporal mantiene la optimalidad de los caminos calculados. Se cumple la subestructura óptima, ya que los caminos más cortos a nodos intermedios forman parte de los caminos más cortos hacia nodos posteriores
- **Complejidad:**
	- Con montículo binario: $O((V + E) \log V)$.
- **Limitación:** no admite pesos negativos.

# Árbol de Recubrimiento Mínimo
**Problema:** Dado un grafo conexo y ponderado, encontrar un subconjunto de aristas que conecte todos los nodos con peso total mínimo, es decir, formar un árbol que cubra todos los nodos con el menor costo posible.
### Algoritmo Kruskal
1. Ordenar todas las aristas por peso.
2. Inicializar un Union-Find para mantener los conjuntos disjuntos de nodos.
3. Iterar sobre las aristas en orden creciente de peso:
    - Agregar la arista si conecta nodos de conjuntos distintos (no forma ciclo).
4. Repetir hasta que todos los nodos estén conectados.
```
Kruskal(V,E)
	Ordenar aristas por peso
	Inicializar Union-Find con cada nodo
	MST = vacío
	for cada arista (u,v) en orden:
	    if u y v no están en el mismo conjunto:
	        agregar arista a MST
	        unir conjuntos de u y v
	return MST
```
### Análisis
- **Correctitud:** la arista de menor peso que lo cruza pertenece a algún MST. La combinación con Union-Find garantiza que no se formen ciclos.
- **Complejidad:**
	- Ordenamiento: $O(E \log ⁡E)$.
	- Operaciones Union-Find (con path compression y union by rank): casi constantes $O(E \alpha(n))$.
	- **Total:** $O(E \log E)$.

