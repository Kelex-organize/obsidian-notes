
# 3.1 Definiciones Iniciales
**Definición:** Un grafo $G = (V,E)$ es una estructura matemática usada para modelar relaciones entre elementos.
- $V$: conjunto de elementos (nodos).
- $E$: conjunto de relaciones (aristas).
### Definiciones y propiedades adicionales
- **Grafo no dirigido:** las aristas representan una relación simétrica (si existe $(u,v)$, entonces existe $(v,u)$)
- **Grafo dirigido:** las aristas representan una relación asimétrica (si existe $(u,v)$ no necesariamente existe $(v,u)$).
- **Camino:** secuencia de nodos $v_1$, $v_2$, … ,$v_n$ donde para para el par consecutivo $(v_i, v_{i+1})$ están unidos por una arista.
- **Ciclo:** camino cerrado donde el primer y ultimo nodos coinciden ($v_1 = v_n$).
- **Grafo conexo:** grafo donde todos los nodos están conectados mediante algún camino.
- **Árbol:** un grafo no dirigido conexo, tiene n-1 aristas y no contiene ciclos. Eliminar una arista lo volvería disconexo.
# 3.2 Representación de Grafos
Un grafo se puede representar de distintas maneras, dependiendo del problema que se quiera resolver, que representación utilizar.
### Matriz de adyacencia
Una matriz cuadrada $n\times n$ ($n = | V|$), donde la entrada $(i,j)$ representa la conexión entre los nodos $i$ y $j$.
**Ventajas:**
- Verificar si existe arista entre dos nodos en $O(1)$.
**Desventajas:**
- Requiere mucha memoria ($O(n^2)$).
- Recorrer nodos adyacentes cuesta $O(n)$.
### Lista de adyacencia
Para cada nodo se mantiene una lista de con los nodos adyacentes.
**Ventajas:**
- Eficiente en memoria cuando el grafo tiene pocas aristas.
- Recorrer nodos adyacentes de un nodo cuesta $O(grado(v))$.
**Desventajas:**
- Verificar si dos nodos están conectados puede costar $O(grado(v))$.
# 3.3 Recorrido de un Grafo
Breve introducción
### Breadth-First Search (BFS)
Explora primero todos los nodos adyacentes a un nodo, avanzando por niveles.
- Comenzar desde un vertice inicial.
- Visitar todos sus nodos adyacentes.
- Continuar con los nodos adyacentes d
```
BFS(G,s)
Descubierto[s] = true y Descubierto[v] = f alse para todo v ∈ V , v 6= s. 2: L[0] que consiste en un ´unico elemento s. 3: i = 0. 4: TBF S = ∅. 5: while (L[i] no est´a vac´ıo) do 6: Creamos una lista vac´ıa L[i + 1]. 7: for (cada nodo u ∈ L[i]) do 8: Consideramos cada arista (u, v) incidente a u. 9: if (Descubierto[v] = f alse) then 10: Descubierto[v] = true 11: Agregamos la arista (u, v) al ´arbol TBF S 12: Agregamos v a la lista L[i + 1] 13: end if 14: end for 15: Incrementamos el contador i. 16: end while return TBF S
```

### Depth-First Search (DFS)

```
DFS-Recursivo(G,s)
	Marco s como explorado
	for cada arista (s,v) incidente a s do
		if v no ha sido explorado then
			invoco DFS - Recursivo (G,v)
		end if
	end for
```

```
DFS-Iterativo(G,s)
	Inicializamos el árbol T_DFS = vacio
	Definimos el arreglo Padre[w]
	Inicializamos la pila S con el elemento s
	Explorado[w] = false \for all w \in V
	while S no está vacío do
		Tomamos un nodo u de S.
		if Explorado[u] = false then
			Explorado[u] true
			for cada arista (u,v) incidente a u do
				Agregamos v a la pila S
				Agregamos v a la pila S.
			end for
		end if
	end while
return T_DFS
```

# Problemas comunes

- **Conjunto de componentes conexas**

- **Bipartitismo**

- **Detectar ciclos** 

- **Orden topológico (DAG)**


